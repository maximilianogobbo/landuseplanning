---
title: "Análise Exploratória de Dados Demográficos"
author: "Maximiliano Gobbo"
date: '2023-05-24'
output:
  pdf_document: default
  word_document: default
  html_document:
    number_sections: yes
editor_options: 
  markdown: 
    wrap: sentence
  chunk_output_type: inline
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r include=FALSE, paged.print=TRUE}
library(sf)      # vector data package introduced in Chapter 2
library(terra)   # raster data package introduced in Chapter 2
library(dplyr)   # tidyverse package for data frame manipulation
library(spData)
library(raster)
library(ows4R)
library(osmdata)
library(geodata)
library(tigris)
library(tidycensus)
library(GSODR)
library(tidyverse)
library(ggplot2,gapminder, magrittr)
library(pander)
library(rgdal)
```

# Introdução

::: {style="text-align: justify"}
De acordo com Biggs et al. (2021), uma das etapas essenciais para construção de modelos socioecológicos resguarda o levantamento de atributos que devem compor a sua estrutura analítica.
Segundo estes autores, é imprescindível que sejam identificados, reconhecidos e analisados cada um dos atributos, de modo a reconhecer o perfil dos dados e sua possível aplicação, seja em termos descritivos, seja em termos de mapeamento das informações.
Nesta perspectiva, Ellis (2020) apresentou que os atributos populacionais, principalmente a densidade demográfica, associados aos antromas são fundamentais para modelagem dos biomas antropogênicos, tanto em escala global, quanto em escala local.
Nos guiando por estas diretrizes acerca dos aspectos demográficos atrelados aos antromas, realizamos neste trabalho a análise exploratória dos dados censitários produzidos pelo Instituto Brasileiro de Geografia e Estatística (IBGE).
A análise exploratória teve por objetivo identificar os atributos que compunham os dados da operação censitária realizada pelo IBGE no ano de 2010 (IBGE, 2013a).
Além disso, tentamos reconhecer características especiais que permitissem a integração dos dados tabulares fornecidos por esta instituição, intuindo ampliar o conjunto de dados para modelagem dos antromas localmente.
Complementarmente, nos empenhamos em avaliar a possibilidade de plotagem destes dados, ou seja, de distribuir espacialmente as informações censitárias em mapeamentos locais.
Esta operação foi realizada no software R®, utilizando as diretrizes investigativas apresentadas por Lovelace et al. (2019) e Anderson (2021) para a análise exploratória e para criação de mapeamentos e plotagens de informações geográficas.
Estes autores apresentaram um formato crítico-analítico em suas obras, demonstrando a lógica envolvida para atingirmos os objetivos apenas apresentados para este trabalho.
Ao longo da análise exploratória, apresentamos sínteses detalhadas das funções utilizadas e que foram extraídas das duas obras apenas tratadas.
Por meio desta pesquisa, realizamos o levantamento de características dos dados censitários, nos formatos vetoriais e raster, que permitiriam o emprego deles na estruturação da árvore de decisão para classificação dos antromas localmente.
Para tanto, ressaltamos que esta foi uma etapa essencial para construção da modelagem dos biomas antropogênicos em linguagem R®.
Nela, reconhecemos atributos dos dados demográficos que se alinhavam àqueles identificados por Gauthier (2021) e Ellis, Beusen e Goldewijk (2020) como fundamentais para o mapeamento dos antromas no R®.

# Carregamento de Dados e Análise Exploratória de Dados Demográficos

Na primeira etapa da análise exploratória dos dados demográficos, os arquivos tabulares fornecidos pelo Instituto Brasileiro de Geografia e Estatística (IBGE) foram baixados da plataforma digital da instituição.
De acordo com o IBGE, o menor nível de desagregação de dados são os microdados do Censo 2010, ou seja, nestes dados estão inseridas as informações para cada uma das cidades investigadas pelo IBGE durante o censo demográfico.
Há nestes dados a distribuição da população municipal em áreas urbanas e rurais e, também, em diferentes sistemáticas urbanas, como sede municipal ou fora da sede municipal.
A página web onde estes dados encontram-se disponibilizados é:

<https://www.ibge.gov.br/estatisticas/sociais/populacao/9662-censo-demografico-2010.html?=&t=microdados>.

Conforme apresentamos na Metodologia, optou-se por utilizar os dados referentes ao Estado de São Paulo como modelo experimental para o mapeamento dos antromas localmente, tendo em vista as diferentes tipologias territoriais presentes no Estado e sua a representatividade na economia, política e gestão nacional, bem como por sua distribuição e dimensão populacional.
Os arquivos baixados da plataforma de dados do IBGE foram incluídos em uma pasta associada ao trabalho (diretório) para ulterior aplicação no software R®.
Nesta pasta encontram-se a documentação de orientação fornecida pelo Instituto Brasileiro, os microdados e as tabelas referentes à população do Estado de São Paulo recenseada no Censo 2010.
Os dados tabulares encontram-se na extensão ".xls" (Microsoft Access 365) para importação no R®.
Sinalizamos que alguns ajustes no conteúdo das tabelas foram necessários, pois, impediam a leitura correta dos arquivos no software.
Portanto, os arquivos tabulares foram abertos no Microsoft Access 365 para remoção de títulos e informações adicionais, como subtítulos, legendas e referências bibliográficas, que constavam nos dados originais.
Assim, nos dados editados permaneceram somente os nomes dos atributos (primeira linha de cada coluna) e os dados censitários de cada atributo necessários para análise.
As operações realizadas no Access 365 não são reportadas neste trabalho, mas os arquivos tabulares editados, em formato ".xls", encontram-se disponíveis no acervo digital desta Tese e podem ser acessados remotamente.
Como informamos, todos os documentos que integram o portifólio dos dados demográficos, incluindo os scripts R e Rmarkdown, foram salvos em um único diretório, de modo a facilitar e dinamizar a operação, a manipulação e a análise de dados no software.
A função getwd (\_) mostra o diretório de trabalho referido, local virtual onde estão todos os documentos desta investigação:

```{r}
getwd() 
```

De todos os documentos baixados da plataforma do IBGE, apenas 3 delas foram utilizadas na primeira fase da análise exploratória, pois, somente estas constavam informações sobre: a localização geográfica dos municípios do Estado de São Paulo, a população em cada uma das subdivisões estabelecidas no recenseamento, a área e/ou a densidade demográfica de cada município.
Na sequência são apresentados separadamente o carregamento de cada uma das tabelas no R® através da função read_excel (\_).
Para que esta função operasse houve indicação do nome do arquivo e do diretório onde estavam salvas as tabelas, conforme ilustra o Script 1 a seguir.
As tabelas foram omitidas no texto, mas podem ser visualizadas no software R® através dos códigos disponibilizados no GitHub desta Tese ou diretamente na plataforma GitHub, por meio do link:

<https://github.com/maximilianogobbo/landuseplanning.git>

Além disso, nesta fase preliminar foram empregadas outras duas funções subsequentemente ao carregamento.
A função names (*), para identificar o nome dos atributos dos conjuntos de dados (primeira linha dos dados tabulares), e a função summary (*), que oferece uma síntese dos dados analisados por ela, seja em termos qualitativos (nominais), seja em termos quantitativos (numéricos e estatísticos).

A primeira tabela carregada no software foi "populacao01.xls", utilizando a função read_excel (*). Sequencialmente, transformamos a tabela em um objeto (dataframe), que recebeu o nome populacao01. Por meio da função names (*), verificamos os nomes dos atributos deste conjunto dados.
Posteriormente, empregamos a função summary (\_) para obtermos uma síntese qualitativa e quantitativa do dataframe populacao01.
O Script 1 (código) ilustra este procedimento preliminar em linguagem R®.

```{r}
library(readxl)
populacao01 <- read_excel("C:/ARQUIVOS COMPUTADOR/DOUTORADO/DOUTORADO TESE/03 DADOS GEOESPACIAIS/02 DENSIDADE DEMOGRÁFICA/populacao01.xls")

names(populacao01)[names(populacao01) == "CIDADES"] = "municipio" #renomeando a coluna cidades para municipios

populacao01

names(populacao01) #a função names() apresenta os títulos em cada uma das colunas do objeto (tabela)#

summary(populacao01)
```

A análise preliminar dos dados de populacao01 revelou alguns aspectos importantes sobre o conjunto.
O primeiro a ser pontuado envolve a função names (*) que indica o nome dos atributos que compõem o dataframe. Estes atributos referem-se às tipologias dos setores censitários (uso do solo) para indicar o número de habitantes recenseados em cada um deles para cada um dos municípios paulistas.\
Conforme verifica-se nos resultados de summary (*), existem 645 linhas (do inglês, length) que representam os municípios do Estado.
Apesar de haver indicação de que os dados do dataframe sejam caracteres (do inglês, character), cada uma das linhas oferece o número de habitantes recenseados em cada uma das tipologias territoriais associadas à cidade, a qual é indicada na primeira linha do conjunto de dados.
Outro aspecto a ser destacado nos resultados apresentados por summary (\_) resguarda ao único atributo interpretado como atributo numérico.
De acordo com o Script 1, o atributo Código da Unidade Geográfica, apesar de ser definido por valores (números), é um descritor numérico, ou seja, uma sequência de número atribuída para determinar a área de referência.
Esse código descritor é entendido, na engenharia de software e na modelagem de banco de dados, como atributos identificadores, os quais não se repetem ao longo do conjunto de dados e são exclusivamente atribuídos a uma entidade, que no caso do dataframe populacao01 são as cidades paulistas.
Dito isso, realizamos o mesmo procedimento analítico com a tabela "populacao02.xls" do diretório, a partir da qual criou-se o dataframe populacao02 e que é descrito no Script 2.

```{r}
populacao02 <- read_excel("C:/ARQUIVOS COMPUTADOR/DOUTORADO/DOUTORADO TESE/03 DADOS GEOESPACIAIS/02 DENSIDADE DEMOGRÁFICA/populacao02.xls")

populacao02

names(populacao02)[names(populacao02) == "Cidades"] = "municipio" #renomeando a coluna cidades para municipios

names(populacao02) #a função names() apresenta os títulos em cada uma das colunas do objeto (tabela)#

summary(populacao02) #a função summary() apresenta as informações sintetizadas acerca do objeto (tabela), onde são já indicados aspectos importantes, como a estrutura do dado vetorial, os valores máximos e mínimos do objeto, entre outras. Estas informações serão de suma importância para a análise exploratória dos dados#
```

Observamos, através dos resultados obtidos pela função names (*), que o conjunto populacao02 possui alguns atributos com o mesmo nome e outros diferentes daqueles presentes no dataframe populacao01. Destacamos os atributos "densidade demográfica" e "área total", que são informações que versam sobre o número de indivíduos em determinada área e a área total do setor censitários, respectivamente.\
Novamente, a função summary (*) revelou que os valores atribuídos a cada uma das tipologias territoriais, bem como as duas informações acima apresentadas, são interpretados como caracteres.
Ao nos depararmos com esse resultado, retomamos o conjunto de dados no Access 365 para tentar identificar o porquê desta resposta da função.
Identificamos que o R® interpreta como caractere as informações tabulares do IBGE devido ao espaçamento presente nas informações numéricas, como evidenciamos na Tabela 1.\
Conforme destaca-se na Tabela 1, os valores associados às unidades numéricas possuem um espaçamento entre centenas e milhares, como verifica-se no cruzamento entre Adamantina e Área urbanizada.
Essa espaçamento impede que o software leia e interprete a informação diretamente como valor, transformando-a, consequentemente, em atributo nominal (caractere).
Diferentemente disso, o atributo Código da Unidade Geográfica é interpretado novamente como atributo numérico, incorrendo no mesmo problema identificado anteriormente para populacao01.
Apesar dos problemas identificados na leitura das duas tabelas carregadas até aqui, realizamos o mesmo procedimento com o arquivo "populacao03.xls", que deu origem ao dataframe populacao03, como mostra o Script 3.
Além de dar sequência a análise preliminar, objetivamos verificar se o problema se repete também neste conjunto de dados.

```{r}
populacao03 <- read_excel("C:/ARQUIVOS COMPUTADOR/DOUTORADO/DOUTORADO TESE/03 DADOS GEOESPACIAIS/02 DENSIDADE DEMOGRÁFICA/populacao03.xls")

populacao03

names(populacao03)[names(populacao03) == "Municípios"] = "municipio" #renomeando a coluna cidades para municipios

names(populacao03) #a função names() apresenta os títulos em cada uma das colunas do objeto (tabela)#

summary(populacao03) #a função summary() apresenta as informações sintetizadas acerca do objeto (tabela), onde são já indicados aspectos importantes, como a estrutura do dado vetorial, os valores máximos e mínimos do objeto, entre outras. Estas informações serão de suma importância para a análise exploratória dos dados#
```

No Script 3, além de apresentar os resultados das duas funções analíticas, reportamos também as 10 primeiras linhas do dataframe populacao03, apresentadas logo após o carregamento dos dados através da função read_excel (*). De acordo com o que trouxemos na Tabela 1, verificamos que o mesmo problema de espaçamento entre as unidades centenas e milhares dos valores dos atributos é reportado no código R para os atributos "População residente Absoluta" e "População residente absoluta total urbana", por exemplo. A confirmação do erro de leitura de valores foi reportada durante a análise da função summary (*), a qual retorna para os dois atributos os valores compreendidos como caracteres.\
Por outro lado, observamos que no conjunto populacao03 existem outros atributos numéricos em sua estrutura, sendo eles: Total Relativa (%), TotalRelativa (%) e Na sede municipal Relativa (%)/n.
Estes atributos, todavia, representam proporções estatísticas sobre a população em cada uma das cidades paulistas, não propriamente sendo atribuídas a dimensões populacionais, como concentração ou densidade demográfica.
Assim, verificamos que há, na estrutura de dados, um problema recorrente, proveniente dos dados fornecidos pelo IBGE.
Além disso, reiteramos que o atributo identificador "Códigos da Unidades Geográficas" integra também este dataframe, sendo este o único indicativo para o posicionamento geográfico das informações presentes nos conjuntos populacao01, populacao02 e populacao03.
Entretanto, não há na estrutura deste atributo nos três conjuntos nenhuma definição direta de informações que espacializem a informação geográfica, como longitude, latitude e altitude dos pontos ou polígonos referentes aos setores censitários.\
Mesmo identificando estes empecilhos apenas tratados, expandimos a análise preliminar com outras duas funções.
A função class (*) para reconhecer o formato estrutural dos três conjuntos e a função dim (*) que fornece o número de linhas e colunas dos conjuntos de dados.
O Script 4 adiante demonstra os resultados obtidos.

```{r}
class(populacao01)
class (populacao02)
class(populacao03)

dim(populacao01)
dim(populacao02)
dim(populacao03)
```

Observamos, nos resultados gerados pela função class (*), que os três conjuntos de dados (populacao01, populacao02 e populacao03) são do tipo dataframes, ou seja, são estruturados seguindo a distribuição da informação em linhas e colunas (tabular, da sigla inglesa, tbl). Nas colunas dos dataframes são reportadas as informações que caracterizam os municípios do Estado de São Paulo, ou seja, a resposta para cada um dos atributos identificados na primeira linha dos dataframes. Por outro lado, a função dim (*) reportou que o dataframe populacao01 é composto por 645 linhas e 10 colunas, enquanto populacao02 é estruturado em 645 linhas e 8 colunas e populacao03 em 645 linhas e 10 colunas.
Diante dessas informações, confirmamos que todas as linhas do dataframe populacao01 possuem correspondência em populacao02 e populacao03, ou seja, todas as cidades apresentadas em populacao01 estão presentes nos outros dois dataframes.
Todavia, constatamos que o número de colunas diverge entre os conjuntos de dados, fato que havíamos observado durante a aplicação das funções names (*) e summary (*).
Isto ocorre porque existem atributos que estão presentes em um que não integram os outros e vice-versa, alterando assim o número de colunas em cada um deles.
Retomando o atributo "código da unidade geográfica" presente nos três dataframes, realizamos uma análise específica para identificar como as informações para cada cidade são lidas pelo software.
Utilizamos novamente a função summary (\_) e filtramos a coluna deste atributo por meio do emprego de colchetes [], os quais são utilizados para especificar o atributo, como demonstramos no Script 5.

```{r}
summary(populacao01["Código da Unidade Geográfica"])
summary(populacao02["Código da Unidade Geográfica"])
summary(populacao03["Código da Unidade Geográfica"])
```

Em consonância aquilo que apresentamos anteriormente, a função summary (\_) retornou informações estatísticas sobre os dados do atributo.
Acima verifica-se que são apresentados os valores mínimo (min.), primeiro quartil (1st Qu.), mediana, média, terceiro quartil (3rd Qu.) e máximo (max.) do conjunto de dados.
Portanto, confirmamos que a interpretação deste atributo identificador pelo software não é feita como código, mas como valores numéricos.
Isso impede a plotagem direta dos dados no mapeamento, requerendo outras informações geográficas para tal.
Nesta perspectiva, realizamos uma nova busca na plataforma do IBGE para encontrarmos os arquivos referentes ao atributo identificador "Códigos das Unidades Geográficas".
Estes arquivos encontram-se disponíveis no link a seguir e podem ser acessados remotamente pelos usuários.
Eles foram baixados e indexados no mesmo diretório de trabalho da análise exploratória.

<https://www.ibge.gov.br/geociencias/organizacao-do-territorio/estrutura-territorial/27385-localidades.html?=&t=acesso-ao-produto>.

Nesta busca, captamos os arquivos raster (shapefiles) disponibilizados pelo IBGE, os quais trazem o conjunto de informações geográficas (geometria dos códigos: longitude, latitude e altitude) que representam os Códigos das Unidades Geográficas dos 3 dataframes (populacao01, populacao02 e populacao03).
Intuíamos com estes shapefiles conectar os dados censitários dos três conjuntos às estruturas espaciais das suas localidades (setor censitário).
Para tanto, o primeiro passo foi o carregamento do arquivo raster no R por meio da função shapefile (\_), a qual é utilizada para ler dados raster no software.
O conjunto de dados carregados por esta função recebeu o nome de localidades_br, convertendo-o em um objeto para análise exploratória, conforme ilustra o Script 6.

```{r}
localidades_br <- shapefile("BR_Localidades_2010_v1.shp")
```

Após o carregamento dos dados raster, realizamos os mesmos procedimentos analíticos até aqui demonstrados.
Utilizamos a função names (*) para identificar os nomes dos atributos que integram o conjunto de dados localidades_br. Por outro lado, a função summary (*) foi empregada para reconhecer a estrutura qualitativa e quantitativa deste objeto (Script 7).

```{r}
names(localidades_br)
names(localidades_br)[names(localidades_br) == "NM_MUNICIP"] = "municipios" 
names(localidades_br)[names(localidades_br) == "NM_UF"] = "estados" 
```

```{r}
summary(localidades_br)
summary(localidades_br["TIPO"])
```

Com base nos nomes dos atributos, verificamos que a coluna "NM_UF", referente ao "Nome da Unidade da Federação", permite que filtremos somente os dados tocantes ao Estado de São Paulo.
Isso permite o recorte do conjunto de dados para atender a área modelo que focalizamos nesta Tese.
Ademais, verificamos que o dataframe de localidade_br é composto por pontos distribuídos geograficamente, tendo em vista a presença dos atributos longitude (LONG), latitude (LAT) e altitude (ALT).
Além disso, há no dataframe características estruturais que auxiliam na espacialização das informações geográficas, sendo elas apresentadas no Script 7 pelas informações coords.x1 e coords.x2.
De modo a testar a espacialização das informações constantes no conjunto de dados localidades_br, aplicamos a função plot (\_) na sequência analítica para visualizarmos a distribuição dos pontos descritos pelo dataframe, como verifica-se na Figura 3.

```{r}
plot(localidades_br) 
```

```{r}
#exportando a figura para o diretório de trabalho
png("C:/ARQUIVOS COMPUTADOR/DOUTORADO/DOUTORADO TESE/03 DADOS GEOESPACIAIS/02 DENSIDADE DEMOGRÁFICA/figura03.png", res = 300, width = 2400, height = 2400)
plot(localidades_br)
dev.off
```

A plotagem ilustra cada um dos 21.886 pontos que integram o conjunto de dados, utilizando para tal plotagem as coordenadas geográficas descritas para cada uma das localidades.
Os espaços em branco, onde não há presença de pontos, representam áreas onde não há presença de população recenseada e/ou que as populações amostradas nestas áreas foram consideradas dentro de setores censitários próximos a sua área de estabelecimento.
Seguindo as diretrizes de análise exploratória apresentadas por Lovelace et al. (2019), transformamos o objeto localidades_br em dois tipos de objetos diferentes para as próximas investigações.
A primeira conversão deste objeto foi para um objeto sf, ou seja, um conjunto de dados simples (do inglês, simple feature collection).
Para tanto, utilizamos a estrutura apresentada na primeira linha de comando do Script 8 a seguir.
Na segunda linha de comando, confirmou-se a criação do conjunto de dados (objeto) localbr_sf:

```{r}
localbr_sf = st_as_sf(localidades_br)
localbr_sf
```

Os resultados apresentam que o conjunto localbr_sf foi criado corretamente, sendo este composto por 21.886 linhas (do inglês, features) e 22 atributos (do inglês, fields) descritos em colunas.
A geometria do conjunto de dados (do inglês, geometry type) encontra-se no formato de pontos (do inglês, points) e é estruturada nas dimensões XY, possuindo valores integrados de xmin, ymin, xmax e ymax dentro da estrutura.
Para além, o conjunto de dados possui o sistema de referência geográfica (CRS) utilizado pelo IBGE na sua estrutura, ou seja, o SIRGAS 2000.
Destacamos ainda que os 22 atributos que integram o conjunto de dados são: *ID, CD_GEOCODI, TIPO, CD_GEOCODB, NM_BAIRRO, CD_GEOCODS, NM_SUBDIST, CD_GEOCODD, NM_DISTRIT CD_GEOCODM, MUNICIPIOS, NM_MICRO, NM_MESO, ESTADOS, CD_NIVEL, CD_CATEGOR, NM_CATEGOR, NM_LOCALID, LONG, LAT, ALT, GMRotation e GEOMETRY*.
Destes, confirmamos a presença de atributos associados ao posicionamento geográfico da informação, como longitude (LONG), latitude (LAT), altitude (ALT) e geometria (GEOMETRY).
Além disso, temos a presença das subdivisões territoriais descritas no conjunto de dados localbr_sf, pois, verificamos que, sequencialmente, o formato tabular dos dados parte do menor nível de agregação, sendo ele bairro (NM_BAIRRO), e chegando a Estados.
Estes resultados, portanto, nos forneceram indícios para compreender a estrutura dos dados e para identificar atributos relevantes para a mineração dos dados em R®.
A segunda conversão realizada no conjunto de dados localidades_br foi feita para um objeto do tipo sp (espacial, do inglês, spatial).
Na primeira linha do Script 9 há a demonstração do código para tal conversão; enquanto na segunda, confirmou-se a criação do objeto localbr_sp.

```{r}
localbr_sp = as(localidades_br, "Spatial")
localbr_sp
```

Os resultados indicam que o conjunto localbr_sp pertence a classe (do inglês, class) de objetos espaciais (do inglês, spatial) e integram um conjunto único de informações (features).
Ademais verificamos que o conjunto possui valores mínimos e máximos de XY, os quais determinam sua extensão (do inglês, extent) para plotagem dos dados, e que estão associados à estrutura CRS do conjunto de dados.
Após a conversão de localidades_br em localbr_sf e localbr_sp, realizamos a plotagem dos dados.
Como não houve nenhuma alteração na estrutura do primeiro conjunto (composição tabular dos dados), a plotagem dos dois outros conjuntos foi a mesma apresentada na Figura 3.
Assim, ocultamos este resultado neste texto, mas pode ser verificado no código disponibilizado no GitHub associado a este trabalho.
Por outro lado, tentamos individualizar os dados do Estado de São Paulo nos três conjuntos apenas tratados, tendo em vista o modelo experimental por nós determinado.
Para tal, utilizamos a função filter (*) para filtrar os dados de São Paulo, utilizando o atributo ESTADOS como parâmetro para a operação. Nos conjuntos localidades_br e localbr_sf foi possível realizar a filtragem, porém, inúmeros valores de atributos eram perdidos dentro dos conjuntos. Em contrapartida, em localbr_sp a função não se aplicou, pois, conforme mostraram os resultados acima, este dataframe é estruturado em uma única linha de dados (único conjunto), não permitindo sua fragmentação (filtragem de dados). Ambas as filtragens não são reportadas aqui, pois envolvem uma quantidade imensa de resultados que não foram aproveitados ao longo do trabalho; mas os resultados da tentativa de filtrar os dados constam no código disponibilizado no GitHub deste trabalho. Intuindo individualizar os dados do Estado de São Paulo, retornamos ao programa Microsoft Access 365 (formato inicial do conjunto de dados disponibilizados pelo IBGE) para filtrar os dados de localidades_br. Filtramos o conjunto de dados utilizando o atributo "NM_UF", que resguarda os Nomes das Unidades da Federação, e selecionando somente as linhas que possuíam "São Paulo" como dado de resposta (caractere inserido na linha da coluna NM_UF). Somente estes dados foram copiados para uma planilha Excel 365 e salvos na extensão ".xls" com o nome localsp.xls. Reiteramos que, seja o arquivo original (Access 365), seja o arquivo produzido (Excel 365) encontram-se na acervo digital deste trabalho e são acessíveis remotamente. Após a produção do arquivo localsp.xls, retornamos ao R®, onde buscamos o arquivo no diretório do trabalho para carregamento no software através da função read_excel (*).
Conjuntamente ao carregamento, criamos o objeto localsp, como ilustra o Script 10.
Posteriormente a isso, confirmamos a criação do objeto.

```{r}
localsp <- read_excel("C:/ARQUIVOS COMPUTADOR/DOUTORADO/DOUTORADO TESE/03 DADOS GEOESPACIAIS/02 DENSIDADE DEMOGRÁFICA/localsp.xls")
names(localsp)[names(localsp) == "NM_MUNICIPIO"] = "municipio" 
names(localsp)[names(localsp) == "NM_UF"] = "estado" 
names(localsp)[names(localsp) == "LONG"] = "longitude" 
names(localsp)[names(localsp) == "LAT"] = "latitude" 
names(localsp)[names(localsp) == "ALT"] = "altitude" 

localsp
head(localsp)
```

A conferência da criação do objeto permitiu que obtivéssemos algumas informações relevantes sobre o conjunto localsp.
Os resultados no Script 10 indicaram que o objeto se estrutura em modelo de dataframe (tradução livre do inglês, tibble), o qual é composto por 2.142 linhas (do inglês, rows) e 21 variáveis (do inglês, variables) distribuídas em colunas, que retratam os atributos deste conjunto de dados.
Os nomes dos atributos (variáveis) foram destacados no Script acima e pontuamos que são os mesmos atributos que compõem localidades_br, excetuando o atributo geometria (GEOMETRY) que não era passível de filtragem no Access 365 e, portanto, não integra o conjunto localsp.
Seguindo as mesmas funções anteriormente utilizadas na análise preliminar (Quadro 10), exploramos o conjunto de dados localsp, intuindo identificar características relevantes para a análise exploratória, como demonstramos no Script 11.

```{r}
names(localsp)

summary(localsp)

dim(localsp)

class(localsp)
```

Através da função names (*) confirmamos os nomes dos atributos associados ao conjunto de dados, ou seja, o nome das variáveis que integram a primeira linha do objeto. Constatamos ainda que localsp é composto por diferentes características espaciais, como "LONG" (longitude), "LAT" (latitude), "ALT" (altitude) e "CD_GEOCODIGO". O atributo CD_GEOCODIGO refere-se ao geocódigo estabelecido pelo IBGE para identificar posições geográficas de polígonos espaciais de cada um dos setores censitários, como havíamos tratado anteriormente. Aditivamente, a função dim (*) evidenciou que o conjunto é composto por 2142 linhas e 21 colunas, as quais descrevem atributos dos dados.
Ademais, a função class (*) revelou que o formato de apresentação dos dados de localsp está estruturado no modelo tabular (da sigla, tbl) e constitui um dataframe (df). Complementarmente, a função summary (*) expandiu as informações sobre cada um dos atributos associados a localsp.
Por meio de sua aplicação, diferentes características foram sumarizadas.
Para os atributos que assumiam o perfil de caractere (do inglês, character), a função retornou o número de linhas em cada coluna (do inglês, length), a classe das informações na coluna (do inglês, class) e o modelo de apresentação (do inglês, mode).
Para as informações que não eram caracteres, houve o retorno de resultados estatísticos para os valores numéricos associados aos atributos, como: valor mínimo, primeiro e terceiro quartil, mediana, média e máximo.
Pontuamos que os resultados estatísticos, no caso de localsp, não são relevantes para a análise exploratória.
Porém, são estes resultados que demonstram quais atributos são interpretados pelo software como atributos numéricos.
Assim, identificamos que os atributos longitude (LONG), latitude (LAT) e altitude (ALT) possuem dados numéricos para cada um dos setores censitários.
Isto favorece o emprego dessas informações para a espacialização da informação geográfica pontual, como identificamos nos conjuntos populacao01, populacao02 e populacao03.
Todavia, para que haja a conexão entre os dados dos três conjuntos apenas tratados e os dados para espacialização da informação (long, lat e alt) presentes em localsp tornou-se imperioso a identificação de um atributo chave que estivesse presente nos quatro dataframes.
Nesta perspectiva, retomamos o supradito sobre o geocódigo do IBGE, o qual, como demonstramos nos Scripts 1, 2 e 3, são retratados pelo atributo "código da unidade geográfica".
Assim, verificamos se os códigos constantes nestes 4 conjuntos de dados eram coincidentes, ou seja, descreviam um atributo chave para a conexão entre as informações de localsp e as informações censitárias descritas em populacao01, populacao02 e populacao03.
Esta operação foi realizada utilizando a função select (*), que permitiu selecionar somente as colunas dos 4 dataframes associadas a este atributo, que em localsp é reportada como "CD_GEOCODIGO", enquanto nos outros três recebe o nome de "Código da Unidade Geográfica". Quando comparados, inúmeras linhas do conjunto localsp não possuíam correspondência nos três conjuntos populacionais. De acordo com os resultados apresentados no Script 4, constatamos por meio da função dim (*) que os dataframes populacionais são formados por 645 linhas, enquanto no Script 11 identificamos que localsp é formado por 2.142 linhas.
Esta diferença significativa entre os dataframes resguarda, em síntese, na divisão territorial estruturada pelo Instituto Brasileiro.
Como apuramos na documentação do Censo Demográfico 2010 (IBGE, 2013a), os pontos amostrais que integram os dados de localsp são mais numerosos porque detalham a malha territorial de forma mais robusta, ou seja, fracionam ainda mais as porções territoriais, chegando ao nível de setor censitário.
Da outra parte, temos em populacao01, populacao02 e populacao03 a aglomeração dos dados dos setores censitários pertencentes ao mesmo município.
No entanto, destacamos que, apesar da junção dos setores censitários dentro do atributo município, há nos Scripts 1, 2 e 3 a demonstração da fragmentação da distribuição das populações municipais em áreas urbanas e rurais, o que nos interessa para construção da árvore de decisão.
Portanto, para guiarmos a ulterior junção das informações espaciais (long, lat e alt) de localsp com os três dataframes populacionais, utilizamos como referência (direcionamento) os códigos presentes em populacao01, populacao02 e populacao03 e unimos aqueles que constavam em localsp.
Isto se deu pela função join (*), a qual permite a inserção de informações de um dataframe em outro, utilizando um atributo como direcionador para sua inserção. Para tal, foi preciso renomear o atributo "Código da Unidade Geográfica" dos três conjuntos populacionais para "CD_GEOCODIGO", o que foi feito através da função rename (*).
Realizamos esta operação para que a função join (*) encontrasse diretamente o atributo chave entre os conjuntos de dados, permitindo assim a inserção dos dados espaciais de localsp nos três conjuntos populacionais. Estas alterações nomenclaturais não são apresentadas no corpo do texto, mas encontram-se no código R disponibilizado no repositório GitHub deste trabalho. No que resguarda a função join (*), apresentamos os resultados também no código do repositório, tendo em vista o número de linhas que integram o objeto.
Dito isso, retomamos o objeto localsp para a análise da espacialização dos dados as quais nos referimos precedentemente.
Sendo os atributos latitude ("LAT"), longitude ("LONG") e altitude ("ALT") essenciais para a plotagem dos dados, utilizamos um filtro interno de colunas na função plot (*), o que foi feito através do emprego de colchetes "[]" na sequência da função, como ilustra o código sobre a Figura 4. As três informações agora tratadas encontravam-se nas colunas de 18, 19 e 20 do dataframe, como identificamos anteriormente na função names (*) do Script 11.
Portanto, utilizamos somente as três colunas para a plotagem do objeto localsp, como demonstramos na Figura 4 a diante:

```{r}
plot(localsp[18:20])
```

```{r}
#exportando a figura para o diretório de trabalho
png("C:/ARQUIVOS COMPUTADOR/DOUTORADO/DOUTORADO TESE/03 DADOS GEOESPACIAIS/02 DENSIDADE DEMOGRÁFICA/figura04.png", res = 300, width = 2400, height = 1700)
plot(localsp[18:20])
dev.off
```

Como havíamos observado, o dataframe de localsp integra um conjunto de informações para delimitação de pontos distribuídos no território, em concordância àquilo que foi apresentado na Figura 3.
Deste modo, ao cruzar as informações dos atributos long, lat e alt, observamos que a plotagem dos dados foi realizada seguindo a mesma lógica pontual da estrutura do dataframe localsp.
Ao atentarmos para a plotagem feita na primeira coluna e segunda linha da Figura 4, observamos que o cruzamento entre os atributos longitude e latitude retrata uma distribuição de pontos na plotagem que se assemelha à estrutura poligonal do Estado de São Paulo.
Entretanto, isto não foi suficiente para confirmarmos a distribuição dos dados no espaço geográfico do território paulista.
Utilizando a função cbind.data.frame (*), individualizou-se as duas colunas do objeto localsp que referem-se a latitude (LAT) e longitude (LONG) para criar um novo conjunto de informações espaciais, cujo nome estabelecido foi pointsp. Este conjunto é composto por 2.142 linhas e duas colunas e está estruturado no formato de dataframe, como indicaram as funções dim (*) e class (\_), respectivamente.
A plotagem dos dados de pointsp, mostra que há uma distribuição gráfica das informações espaciais do Estado de São Paulo, porém há uma deformação (achatamento) na estrutura poligonal do território paulista, como ilustra a Figura 5 a seguir.

```{r include=FALSE}
cbind.data.frame(localsp$latitude, localsp$longitude)
pointsp = cbind.data.frame(localsp$latitude, localsp$longitude)
dim(pointsp)
class(pointsp)
```

```{r}
plot(pointsp)
```

```{r}
#exportando a figura para o diretório de trabalho
png("C:/ARQUIVOS COMPUTADOR/DOUTORADO/DOUTORADO TESE/03 DADOS GEOESPACIAIS/02 DENSIDADE DEMOGRÁFICA/figura05.png", res = 300, width = 2400, height = 1700)
plot(pointsp)
dev.off
```

Lovelace et al. (2019) e Anderson (2021) apresentam que para transformar um dataframe em um sistema de localização espacial de pares ordenados deve-se utilizar a função sfheaders::sfg\_.
Através dela é possível direcionar a criação de pontos, matrizes ou dataframes.
Como destacamos precedentemente, objeto pointsp foi estruturado no formato de dataframe; portanto utilizamos a estrutura de multipontos (do inglês, multipoint) para leitura e conversão do objeto em pares ordenados.
Com isso, criamos um objeto, o qual recebeu o nome de multipointsp_sfg.
Ao analisarmos multipoints_sfg verificamos que ele se constituía de pares ordenados XY, apresentando dois valores entre as vírgulas que correspondem ao par para caracterização e, consequentemente, para plotagem de cada um dos pontos que integravam o conjunto de dados.
Por meio da função class (*) verificamos que a construção dos pares ordenados foi feita conforme indicado, seguindo a lógica de múltiplos pontos e com geometria de recursos simples (sfg, do inglês, simple feature geometries). De modo a analisar os mesmos dados de pointsp em uma estrutura poligonal, realizamos o mesmo procedimento acima, entretanto fazendo a substituição de multipoint na função sfg* por polygon (do inglês, polígonos), o que permitiu a criação do conjunto polygonsp_sfg.
Empregando novamente a função class (*), verificamos que o conjunto polygonsp_sfg também foi criado com base em pares ordenados XY, seguindo a estrutura de polígonos e integrando uma geometria de recursos simples (sfg). Intuindo comparar as estruturas de multipointsp_sfg e de polygonsp_sfg, realizamos a plotagem destes conjuntos por meio da função plot (*), como ilustra a Figura 6.

```{r}
multipointsp_sfg = sfheaders::sfg_multipoint(obj = pointsp)
```

```{r include=FALSE}
multipointsp_sfg
```

```{r}
class(multipointsp_sfg)
```

```{r include=FALSE}
sfheaders::sfg_polygon(obj = pointsp)
polygonsp_sfg = sfheaders::sfg_polygon(obj = pointsp)
```

```{r include=FALSE}
polygonsp_sfg
```

```{r}
class(polygonsp_sfg)
```

```{r}
par(mfrow=c(1,2))
plot(multipointsp_sfg)
plot(polygonsp_sfg)
```

```{r}
#exportando a figura para o diretório de trabalho
png("C:/ARQUIVOS COMPUTADOR/DOUTORADO/DOUTORADO TESE/03 DADOS GEOESPACIAIS/02 DENSIDADE DEMOGRÁFICA/figura06.png", res = 300, width = 2400, height = 1700)
par(mfrow=c(1,2))
plot(multipointsp_sfg)
plot(polygonsp_sfg)
dev.off
```

Notamos que o conjunto multipointsp_sfg distribui de forma clara cada um dos pontos provenientes de localsp.
Em contrapartida, em polygonsp_sfg evidenciamos que há uma conexão entre os pontos do conjunto de referências geográficas, o que prejudica a individualização das informações geográficas de localsp.
Entretanto, verificamos que em ambos há uma forma similar de distribuição dos dados na plotagem produzida.
Moreno & Basille (2021) apresentam que através da função sf_use_s2() é possível integrar um objeto do tipo sf, como o objeto multipointsp_sfg, à uma estrutura esférica da projeção planetária.
Segundo estes autores, esta estrutura esférica de s2 é fundamentada na base do Google Earth® e permite a plotagem de pares ordenados XY de pontos sobre este padrão de visualização.
Assumindo isto, empregamos a função st_buffer (\_) para ler o conjunto de dados multipointsp_sfg e estruturar um conjunto de dados que recebeu o nome de sppontos_s2.
Concomitantemente, utilizamos a função sf_use_s2 para indicar que o objeto deveria ser lido neste contexto esférico para plotagem.
Após a criação do objeto sppontos_s2, realizamos nova plotagem para analisar comparativamente o novo modelo de plotagem e aqueles referentes aos conjuntos multipointsp_sfg e polygonsp_sfg.
Na Figura são reportadas as três plotagens.

```{r}
sppontos_s2 = st_buffer(multipointsp_sfg, 1)
sf_use_s2(TRUE)
```

```{r}
par(mfrow=c(1,3))
plot(multipointsp_sfg)
plot(polygonsp_sfg)
plot(sppontos_s2)
```

```{r}
#exportando a figura para o diretório de trabalho
png("C:/ARQUIVOS COMPUTADOR/DOUTORADO/DOUTORADO TESE/03 DADOS GEOESPACIAIS/02 DENSIDADE DEMOGRÁFICA/figura07.png", res = 300, width = 2400, height = 1700)
par(mfrow=c(1,3))
plot(multipointsp_sfg)
plot(polygonsp_sfg)
plot(sppontos_s2)
dev.off
```

Diante da Figura 7, notamos que a terceira estrutura, criada a partir de sf_use_s2, gera uma estrutura espacial com os pontos descritos na estrutura do conjunto sppontos_s2.
Para compreendermos melhor a estrutura dos três modelos, empregamos a função ncell (\_) para identificar o número de células presentes em cada um dos três dataframes.

```{r}
ncell(multipointsp_sfg)
ncell(polygonsp_sfg)
ncell(sppontos_s2)

dim(multipointsp_sfg)
dim(polygonsp_sfg)
dim(sppontos_s2)
dim(localsp)

crs(multipointsp_sfg)
crs(polygonsp_sfg)
crs(sppontos_s2)
crs(localsp)

crs(localidades_br)
```

Os resultados obtidos por esta função revelaram que polygonsp_sfg e sppontos_s2 representam um único pixel (célula) na plotagem, ou seja, os dados que integram os dois dataframes formam um único objeto espacial.
Em contrapartida, multipointsp_sfg é estruturado por 4.284 pontos distribuídos na plotagem, o que permite a fragmentação dos dados para melhor espacializar a informação censitária no Estado.
Portanto, seja polygonsp_sfg, seja sppontos_s2 foram desconsiderados nas análises subsequentes.
Em faces destes resultados sobre o particionamento da informação espacialmente e objetivando assimilar outros atributos espaciais importantes, expandimos a seleção de atributos que integrava o conjunto multipointsp_sfg.
Para tanto, retomamos o conjunto pointsp e selecionamos outros dois atributos, sendo eles: NM_MUNICIPIO e NM_LOCALIDADE.
Conjuntamente à seleção, criamos um conjunto de dados, que recebeu o nome de localsp Neste, modificamos, por meio da função rename (*), os nomes destes atributos para município e localidade, respectivamente. Analisando localsp, constatamos que para um mesmo município (NM_MUNICIPIO) existem diferentes localidades (NM_LOCALIDADE), ou seja, existem subdivisões que demarcam pontos estratégicos para as análises censitárias realizadas pelo IBGE. De acordo com a documentação técnica do instituto brasileiro (IBGE, 2013a), as diferentes localidades são setores censitários associados às sedes municipais, mas que integram perfis diferentes, podendo enquadrar-se como distritos, aglomerados populacionais, vilas, entre outros. Por meio da função dim (*) identificamos que, assim como multipoints_sfg, localsp é constituído por 2.142 linhas, porém possui duas colunas a mais que o conjunto anterior, pois, inserimos os dois novos atributos na seleção supramencionada.
Ao empregarmos a função crs (*), para examinar se este dois dataframes possuíam sistema de coordenadas geográficas associados à sua estrutura, detectamos que nenhum deles possuía. Diante disso, aplicamos a mesma função no conjunto percursos dos dados, localidades_br, e constatamos que este estava estruturado no Sistema de Referência Geocêntrico para as Américas (SIRGAS 2000) e descritos no formato WKT (sigla do inglês, Well-Know Text). Com base nestas constatações, retomamos a obra de Lovelace et al. (2019) e verificamos que através da função dplyr::select (*) é possível selecionar colunas dentro de dataframes que são de interesse para a espacialização da informação geográfica, intuindo estruturar um sistema de referenciamento geográfico para os dados.
Nesta perspectiva, utilizamos o dataframe localsp e filtramos as informações de latitude e longitude deste conjunto para criar outro objeto, cujo nome dado foi geometriasp.
Utilizando os dados de geometriasp, realizamos a junção das duas colunas para estruturar 3 novos conjuntos de dados orientados espacialmente.
Para tal, empregamos a função sfheaders::sfg, objetivando ler o conjunto de dados de geometriasp e formar um conjunto de dados no formato de lista (linestring), outro no formato de polígono (polygon) e outro no formato de pontos múltiplos (multipoint).
Para cada um destes formatos, criamos uma lista de valores, os quais receberam os respectivos nomes: listacoord_sfg, poligoncoord_sfg e pontoscoord_sfg.
Após a criação dos três conjuntos de valores supracitados, plotamos os dados para visualizar a distribuição espacial associada aos conjuntos, como ilustra a Figura 8.

```{r}
geometriasp = localsp[18:19]
geometriasp

listacoord_sfg = sfheaders::sfg_linestring(obj = geometriasp)

poligoncoord_sfg = sfheaders::sfg_polygon(obj = geometriasp)

pontoscoord_sfg = sfheaders::sfg_multipoint(obj = geometriasp)
```

```{r}
listacoord_sfg
poligoncoord_sfg
pontoscoord_sfg
```

```{r}
par(mfrow=c(1,3))
plot(listacoord_sfg)
plot(poligoncoord_sfg)
plot(pontoscoord_sfg)
```

```{r}
#exportando a figura para o diretório de trabalho
png("C:/ARQUIVOS COMPUTADOR/DOUTORADO/DOUTORADO TESE/03 DADOS GEOESPACIAIS/02 DENSIDADE DEMOGRÁFICA/figura08.png", res = 300, width = 2400, height = 1700)
par(mfrow=c(1,3))
plot(listacoord_sfg)
plot(poligoncoord_sfg)
plot(pontoscoord_sfg)
dev.off
```

A plotagem dos conjuntos listacoord_sfg e poligoncoord_sfg mostrou que ambos orientavam uma plotagem que unia os dados, criando um desenho contínuo com os valores de cada um dos pontos.
Por outro lado, pontoscoord_sfg representou cada um dos pares ordenados de XY (longitude e latitude) distribuídos descontinuamente na plotagem dos dados, ou seja, na representação gráfica deste conjunto foi possível individualizar os pontos distribuídos no território que são orientados pelo dataframe.
Mesmo que divergentes entre si, visualizamos que os três conjuntos estruturaram um padrão de plotagem que se assemelha ao contorno territorial do Estado de São Paulo.
Após a análise da distribuição das informações geográficas de latitude e longitude dos conjuntos acima tratados, os quais eram provenientes de geometrias, revisitamos o arquivo de base localsp.xls para ampliar o conjunto de dados analisados.
Portanto, retornamos ao Excel 365 para filtrar novamente os dados fornecidos pelo IBGE.
O arquivo referido foi duplicado e o novo recebeu o nome localsp02.xls.
Neste arquivo, aplicamos os filtros de colunas para selecionar outros atributos de interesse.
No atributo (variante) "NM_CATEGORIA" filtramos somente os dados que se referiam às "CIDADE", excluindo as demais tipologias territoriais para este atributo.
Do 2.142 dados que integravam o arquivo completo, restaram apenas 636 resultados.
Estes 636 resultados estavam subdivididos entre urbano e rural, segundo as informações constantes no atributo "TIPO" do arquivo localsp02.xls.
Utilizando a função read_excel (*), carregamos o arquivo localsp02.xls no R® e criamos o objeto localsp02 com os dados acima referidos. Seguidamente à criação do conjunto, empregando a função rename (*), renomeamos os títulos das colunas (nome dos atributos) NM_MUNICIPIO, NM_UF, LONG, LAT e ALT, as quais receberam os nomes município, estado, longitude, latitude e altitude, respectivamente.
A alteração dos nomes das colunas foi feita com o objetivo de criar pontos para a ulterior junção do conjunto de dados localsp02 e os conjuntos referentes às populações (populacao01, populacao02 e populacao03).
Com os dados carregados de localsp02, filtramos três atributos de interesse: municipio, latitude e longitude e aplicamos a função cbind.data.frame (\_) para criar um conjunto de dados, que recebeu o nome de matrixlocalsp02.
A plotagem destes dados é representada na Figura 9 a seguir.

```{r}
localsp02 <- read_excel("C:/ARQUIVOS COMPUTADOR/DOUTORADO/DOUTORADO TESE/03 DADOS GEOESPACIAIS/02 DENSIDADE DEMOGRÁFICA/localsp02.xls")
```

```{r}
names(localsp02)[names(localsp02) == "NM_MUNICIPIO"] = "municipio" 
names(localsp02)[names(localsp02) == "NM_UF"] = "estado" 
names(localsp02)[names(localsp02) == "LONG"] = "longitude" 
names(localsp02)[names(localsp02) == "LAT"] = "latitude" 
names(localsp02)[names(localsp02) == "ALT"] = "altitude"
localsp02
```

```{r}
matrixlocalsp02 = cbind.data.frame(localsp02$municipio, localsp02$latitude, localsp02$longitude)
names(matrixlocalsp02)[names(matrixlocalsp02) == "localsp02$municipio"] = "municipio"
names(matrixlocalsp02)[names(matrixlocalsp02) == "localsp02$latitude"] = "latitude"
names(matrixlocalsp02)[names(matrixlocalsp02) == "localsp02$longitude"] = "longitude"
matrixlocalsp02
```

```{r}
plot(matrixlocalsp02)
```

```{r}
#exportando a figura para o diretório de trabalho
png("C:/ARQUIVOS COMPUTADOR/DOUTORADO/DOUTORADO TESE/03 DADOS GEOESPACIAIS/02 DENSIDADE DEMOGRÁFICA/figura09.png", res = 300, width = 2400, height = 1700)
plot(matrixlocalsp02)
dev.off
```

Observamos que o cruzamento das informações de latitude e longitude, representados na segunda linha e terceira coluna, forneceram uma representação espacial próxima àquela encontrada na estrutura poligonal do Estado de São Paulo, o que reafirmou a organização dos dados para plotagem dos dados.
Realizada esta operação para atestar a distribuição dos dados na plotagem, utilizamos a função unite (*) para unir as colunas latitude e longitude. Por meio dela estruturamos uma coluna única, cujo nome dado ao atributo foi geom, tendo em vista o caráter de geoposicionamento dos dados presentes nela. Na função aplicamos o separador (sep) vazio entre as aspas ("*") para unir as informações latitude longitude e removemos as duas colunas ("remove = TRUE").
De modo a facilitar nossa análise, criamos um objeto com estes novos dados, o qual recebeu o nome de cidadegeom.
Este dataframe está organizado em 645 linhas e 2 colunas, onde a primeira coluna representava os nomes dos municípios do Estado de São Paulo e a segunda referia-se ao posicionamento geográfico baseado em latitude e longitude (separadas por pelo espaço vazio acima tratado).
Após a estruturação de cidadegeom, tentamos unir este conjunto ao conjunto populacao01, empregado as funções: left_join (*), inner_join (*), right_join (*), full_join (*) e anti_join (\_).
Entretanto, segundo os resultados observados no código R, nenhuma das funções uniu as informações dos dois conjuntos de forma integral, ou seja, houve durante a junção dos dataframes perdas substanciais dos dados referentes a diferentes atributos que os integravam.
Intuindo otimizar o processamento dos dados no R, bem como nossa análise, optamos por reestruturar o conjunto de dados localsp02.xls no Excel 365.
Para tanto, duplicamos este arquivo e nomeamos o arquivo duplicado de dados_vetoriais_sp.xls.
Neste arquivo, inserimos as informações demográficas constantes nos conjuntos populacao01.xls e populacao02.xls.
Os dados selecionados em cada um dos conjuntos estão descritos a seguir:

-   Do conjunto populacao01 foram utilizadas as colunas: Área Urbanizada, Área não urbanizada, Área Urbana Isolada, Área Rural (Exceto Aglomerado), Aglomerado Rural de Extensão Urbana, Aglomerado Rural Povoado, Aglomerado Rural Núcleo e Outros Aglomerados Rurais Raros;

-   Do conjunto populacao02 foram utilizadas as colunas: Total, Área total (Km²) e Densidade Demográfica (hab/km²);

    Posteriormente à inserção das colunas dos dois conjuntos acima no conjunto dados_vetoriais_sp.xls, este arquivos de dados foi carregado no R® por meio da função read_excel (*). Com este arquivo, criamos o objeto vetor_sp, o qual estava estruturado no formato de dataframe (tabela) e possuía 645 linhas de dados e 32 colunas de atributos. Estas inferências foram confirmadas pelas funções class (*) e dim (*). Conjuntamente, aplicamos as funções names (*), para verificar o nome de cada um dos atributos associados a vetor_sp, e summary (*), para analisar a composição dos dados do conjunto.\
    Através da função names (*) identificamos que os 32 atributos do conjunto de dados vetor_sp não sofreram alterações após o carregamento no software, mantendo os menos nomes utilizados no arquivo dados_vetoriais_sp.xls.
    Constatamos ainda que estes dividem-se entre características populacionais, como População Total e Area Total (km²), informações de posicionamento geográfico das características populacionais, como longitude, latitude e altitude) e atributos estabelecidos para classificação no sistema do IBGE, como GM_PONTO_sk.
    Complementarmente, a função summary (\_) forneceu a síntese sobre os atributos que compõem o conjunto vetor_sp.
    Observamos nos resultados que alguns dos atributos foram reportados como caracteres, ou seja, as informações constantes nas linhas destas colunas representavam atributos nominas, como município, microrregião e mesorregião.
    Por outro lado, outras colunas possuíam atributos numéricos a elas associadas e foram reportadas as sínteses estatísticas nos resultados apresentados pela função, como verificamos em longitude, latitude e altitude.
    Utilizando dois dos atributos numéricos de vetor_sp, sendo eles longitude (coluna 29) e latitude (coluna 30), realizamos a plotagem destas informações, intuindo confirmar possibilidade de espacialização dos dados do conjunto.
    Como mostramos anteriormente para outras plotagens, estes dois atributos de vetor_sp foram selecionados através do uso de colchetes [], onde indicamos as colunas a serem utilizadas para plotagem.
    A Figura retrata a plotagem destes dados para confirmação da possibilidade de espacialização dos dados na representação gráfica.

```{r}
cidadegeom = matrixlocalsp02 %>% unite("geom", latitude:longitude, sep = " ", remove = TRUE)
cidadegeom
```

```{r eval=FALSE, include=FALSE}
matrixlocalsp02_unite  = matrixlocalsp02 %>%
  unite("geom", latitude:longitude, sep = " ", remove = TRUE)
matrixlocalsp02_unite
```

```{r}
vetor_sp <- read_excel("C:/ARQUIVOS COMPUTADOR/DOUTORADO/DOUTORADO TESE/03 DADOS GEOESPACIAIS/02 DENSIDADE DEMOGRÁFICA/dados_vetoriais_sp.xls")
```

```{r}
vetor_sp

names(vetor_sp)

class(vetor_sp)

dim(vetor_sp)

summary(vetor_sp)
```

```{r}
plot(vetor_sp[29:30])
```

```{r}
#exportando a figura para o diretório de trabalho
png("C:/ARQUIVOS COMPUTADOR/DOUTORADO/DOUTORADO TESE/03 DADOS GEOESPACIAIS/02 DENSIDADE DEMOGRÁFICA/figura10.png", res = 300, width = 2400, height = 1700)
plot(vetor_sp[29:30])
dev.off
```

Com base na plotagem dos dados de vetor_sp (Figura 10), notamos que espacialização dos dados associados aos longitude e latitude seguiu um formato que se assemelha à estrutura poligonal do Estado de São Paulo.
Isso favoreceu a confirmação de que este conjunto de dados possuía uma estrutura geoespacial que favorecia seu emprego como referência para a plotagem dos dados demográficos no território paulista.
Utilizando os dados de vetor_sp, realizamos a junção das duas colunas (longitude e latitude) para estabelecer 3 conjuntos de dados orientados espacialmente.
Novamente, empregamos a função sfheaders::sfg com o objetivo de ler o objeto e estruturar três novos conjuntos de dados: um no formato de lista (linestring), outro no formato de polígono (polygon) e outro no formato de pontos múltiplos (multipoint).
Para cada um dos formatos, foram criadas listas de pares ordenados XY, os quais receberam os respectivos nomes: listacoord_sfg, poligoncoord_sfg e pontoscoord_sfg.
Subsequente à criação dos três conjuntos, tentamos plotar os dados que os integravam para analisar a espacialização da informações geográfica.
Entretanto a tarefa não foi completada pelo software, o qual acusou um erro na estrutura do conjunto de dados.
Segundo o alerta feito, evidenciamos que os três conjuntos foram interpretados como uma única camada, não permitindo a espacialização da informação e, consequentemente, a plotagem dos dados.
Em contrapartida, objetivando criar objetos do tipo coleção de dados simples (simple feature collection), empregamos a função sfheader::sf\_ nos três conjuntos de dados apenas tratados.
Por meio da estrutura da função, indicamos a criação de outros três conjuntos a partir deles, sendo eles: listacoord_sp_sf no formato de lista (linestring), baseado em listacoord_sfg; poligoncoord_sp_sf no formato de polígono (polygon), proveniente de poligoncoord_sfg; e pontoscoord_sp_sf no formato de pontos múltiplos (multipoint), derivado de pontoscoord_sfg.
Conjuntamente, aplicamos a função st_crs (\_) em cada um dos três novos conjuntos para indicar qual é o sistema de georreferenciamento a ser utilizado por eles, optando por "SIRGAS 2000", sendo este o mesmo empregado pelo IBGE.\
De acordo com os resultados reportados pelo software, os formatos lista e multipontos foram criados com sucesso.
Em compensação, o conjunto de base poligonal, poligoncoord_sp_sf, não pôde ser criado, sugerindo, nos resultados, um erro devido às dimensões no conjunto de dados.
Com isto em vista, realizamos a plotagem dos conjuntos listacoord_sp_sf e pontoscoord_sp_sf, de modo a identificar se houve a distribuição dos pontos na plotagem conforme esperávamos (Figura 11).

```{r}
listacoord_saopaulo = sfheaders::sfg_linestring(obj = vetor_sp, x = "Longitude", y = "Latitude", z = "Altitude")
listacoord_saopaulo
```

```{r}
poligoncoord_saopaulo = sfheaders::sfg_polygon(obj = vetor_sp, x = "Longitude", y = "Latitude", z = "Altitude")
poligoncoord_saopaulo
```

```{r}
pontoscoord_saopaulo = sfheaders::sfg_multipoint(obj = vetor_sp, x = "Longitude", y = "Latitude", z = "Altitude")
pontoscoord_saopaulo
```

Tentou-se plotar os dados criados anteriormente, entretanto a tarefa não foi completada devido a um erro.

```{r eval=FALSE, include=FALSE}
par(mfrow=c(1,3))
plot(listacoord_saopaulo)
plot(poligoncoord_saopaulo)
plot(pontoscoord_saopaulo)
```

```{r}
listacoord_sp_sf = sfheaders::sf_linestring(obj = listacoord_saopaulo)
st_crs(listacoord_sp_sf) = "SIRGAS 2000"
listacoord_sp_sf
```

```{r eval=FALSE, include=FALSE}
poligoncoord_sp_sf = sfheaders::sf_polygon(obj = poligoncoord_saopaulo)
st_crs(poligoncoord_sp_sf) = "SIRGAS 2000"
poligoncoord_sp_sf
```

```{r}
pontoscoord_sp_sf = sfheaders::sf_multipoint(obj = pontoscoord_saopaulo)
st_crs(pontoscoord_sp_sf) = "SIRGAS 2000"
pontoscoord_sp_sf
```

```{r}
par(mfrow=c(1,2))
plot(listacoord_sp_sf)
plot(pontoscoord_sp_sf)
```

```{r}
#exportando a figura para o diretório de trabalho
png("C:/ARQUIVOS COMPUTADOR/DOUTORADO/DOUTORADO TESE/03 DADOS GEOESPACIAIS/02 DENSIDADE DEMOGRÁFICA/figura11.png", res = 300, width = 2400, height = 1700)
plot(listacoord_sp_sf)
dev.off
```

```{r}
png("C:/ARQUIVOS COMPUTADOR/DOUTORADO/DOUTORADO TESE/03 DADOS GEOESPACIAIS/02 DENSIDADE DEMOGRÁFICA/figura12.png", res = 300, width = 2400, height = 1700)
plot(pontoscoord_sp_sf)
dev.off
```

```{r}
class(pontoscoord_sp_sf)
dim(pontoscoord_sp_sf)
names(pontoscoord_sp_sf)
summary(pontoscoord_sp_sf)
ext(pontoscoord_sp_sf)
crs(pontoscoord_sp_sf)

ncell(pontoscoord_sp_sf)
```

Os resultados obtidos pela plotagem dos dois objetos, listacoord_sp_sf e pontoscoord_sp_sf, assemelham-se ao polígono do Estado de São Paulo.
Entretanto, nostamos que por se tratar de uma lista, a plotagem de listacoord_sp_sf ocorre de forma contínua, ou seja, cada um dos pontos é conectado, criando um emaranhado entre os pontos georreferenciados.
Por outro lado, a plotagem do conjunto de dados pontoscoord_sp_sf descreve os pontos distribuídos no território de São Paulo de acordo com as informações geográficas de latitude e longitude (localidade) que integram o objeto.
Diante disso, realizamos uma investigação para reconhecer as características essenciais atreladas a este conjunto de dados (pontoscoord_sp_sf).
O objetivo foi confirmar se os dados se mantinham sua propriedade de pares ordenados XY, permitindo sua integração com o conjunto vetor_sp, e se mantinham a sua individualidade para distribuição espacial das informações populacionais na plotagem.
Os resultados obtidos pela função class (*) apontaram que o conjunto pontoscoord_sp_sf foi estruturado em formato de dataframe, compondo um coleção de dados simples (sf). Ao empregarmos as funções dim (*) e names (*), notamos que este dataframe possuía apenas uma linha e duas colunas, as quais receberam os nomes id e geometry, que eram, respectivamente, a sequência numérica dos pontos XY (longitude e latitude) e a geometria que descrevia cada ponto determinado pelos parênteses na sequência numérica. Complementarmente, por meio da função summary (*) confirmamos a estrutura de pontos múltiplos (multipoint z), todavia, indicando uma única lista em sua composição.
Por outro lado, a função ext (*) revelou que a extensão espacial deste conjunto de dados estava estruturada, possuindo valor mínimos e máximos de X e Y (xmin, xmax, ymin e ymax). Entretanto, ao aplicarmos a função ncell (*), e considerando os resultados indicados pela função dim (\_), notamos que apenas duas células foram estruturadas neste conjunto de dados, o que implica na estrutura de uma camada única indivisível para tratamento dos dados.
Conforme observamos na plotagem deste conjunto de dados, a espacialização das informações ocorreu de forma relevante, porém a indivisibilidade dos múltiplos pontos inviabiliza o integração de pontoscoord_sp_sf na estrutura de dados de vetor_sp.
Portanto, confirmamos que a forma mais adequada para plotagem dos dados, sem que haja perdas significativas ou junções desnecessárias e indivisíveis, é recorrer ao uso do conjunto em sua integralidade, selecionando como base para plotagem as informações geográficas de latitude, longitude e altitude.
Assim, o conjunto vetor_sp, pelas características descritas ao longo da análise, representou o caminho mais adequado para a correlação de dados, tendo em vista os atributos que o integram, tanto numéricos (quantitativos), quanto nominais (qualitativos).

# Conclusões

Com base na análise exploratória de dados demográficos, conseguimos identificar os atributos que integram as informações censitárias nacionais.
Verificamos que os atributos numéricos que integram os conjuntos populacao01, populacao02 e populacao03, disponibilizados pelo Instituto Brasileiro, possuem diferenças estruturais que devem ser corrigidas para que o software possa processar as informações demográficas e espaciais corretamente.
Averiguamos ainda que as informações longitude e latitude são fundamentais para a plotagem de dados em todos os dataframes que analisamos.
Através delas, constatamos que a plotagem dos informações censitárias pode ser ordenada dentro do polígono estruturado para o Estado de São Paulo.
Confirmamos também que o atributo chave "CD_GEOCODIGO" pode ser utilizado para a integração dos dados tabulares disponibilizados na plataforma do IBGE.
Além disso, conseguimos identificar quais funções mostravam-se fundamentais para manutenção da integridade das informações geográficas, sem perdas estruturais de atributos e/ou junções não partitivas para a plotagem dos dados, mantendo a conformidade dos dados adquiridos diretamente da instituição brasileira.
Finalmente, reconhecemos as diferentes formas de estruturação de objetos no software R, constatando aquela mais adequada para a correlação de dados vetoriais e raster (shapefile).
:::
